const { exec, spawn } = require('child_process')
const path = require('path')
const fs = require('fs')
const readline = require('readline')



/*    Function to format the output of the command    */
const formatOutput = data => { // This function takes data as an argument...

    return data.split('\n').map(line => { //...and splits the data by newline characters, then maps over the resulting array...

        const rewriteMatch = line.match(/^Rewrite\s+([a-f0-9]+)\s+\((\d+)\/(\d+)\)\s+\((\d+)\s+seconds?\s+passed,\s+remaining\s+(\d+)\s+predicted\)(?:\s+.*)?$/) //...then checks if the line matches the rewrite regex...

        if (rewriteMatch) { //...and if it does...

            const [_, hash, current, total, secondsPassed, secondsRemaining] = rewriteMatch //...extracts the hash, current, total, secondsPassed, and secondsRemaining...

            return `Rewrite: ${hash}\nCurrent operation: ${current} / ${total}\nTime passed: ${formatTime(secondsPassed)}\nTime remaining: ${formatTime(secondsRemaining)}\n` //...and returns the formatted rewrite output
        }

        return line //...otherwise returns the line as is...

    }).join('\n') //...then joins the array back into a string
}


/*    Function to format time in HH:MM:SS format    */
const formatTime = seconds => { // This function takes seconds as an argument...

    const hrs = Math.floor(seconds / 3600) //...and calculates the hours...

    const mins = Math.floor((seconds % 3600) / 60) //...minutes...

    const secs = seconds % 60 //...and seconds...

    return `${hrs.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}` //...then returns the formatted time
}


/*    Function to execute a command and return a Promise    */
const execCommand = (command, options = {}) => { // This function takes a command and optional options as arguments and returns a Promise...
    return new Promise((resolve, reject) => { //...which takes two arguments, resolve and reject...

        console.log(`Executing command: ${command}`) //...and logs the command to the console...

        exec(command, { maxBuffer: 1024 * 1024 * 10, ...options }, (error, stdout, stderr) => { //...then executes the command using the exec function additionally passing options, in which maxBuffer is hardcoded as 1024 * 1024 * 10 and in which cwd as rootDir is included when called from main when answer === '2', and also passing the error, stdout, and stderr to a callback function...

            if (error) { //...wherein if there is an error...

                reject(`Error: ${stderr}`) //...the Promise is rejected with the error message...

            } else { //...otherwise...

                resolve(stdout.split('\n').filter(line => line.trim() !== '')) //...the Promise is resolved with the output of the command
            }
        })
    })
}


// /*    Function to spawn a command and provide real-time feedback    */
const spawnCommand = (command, args = [], options = {}) => { //This function takes a command, arguments, and optional options as arguments and returns a Promise...

    return new Promise((resolve, reject) => { //...which takes two arguments, resolve and reject...

        const child = spawn(command, args, { stdio: ['inherit', 'pipe', 'pipe'], ...options }) //...spawns the command with stdio set to 'inherit' to provide real-time feedback...

        let output = '' //...initializes a variable output...
        let errorOutput = '' //...and a variable errorOutput...

        child.stdout.on('data', data => { //...captures stdout by listening for the data event on stdout...

            output += data.toString() //...appending the data to the output...

            process.stdout.write(formatOutput(data.toString())) //...and writing the formatted output to the console...
        })

        child.stderr.on('data', data => { //...captures stderr by listening for the data event on stderr...

            errorOutput += data.toString() //...appending the data to the errorOutput...

            process.stderr.write(data.toString()) //...and writing the data to the console...
        })

        child.on('close', code => { //...listens for the close event...

            if (code !== 0) { //...and if the exit code is not 0...

                reject(new Error(`Command failed with exit code ${code}\n${errorOutput}`)) //...rejects the Promise with an error...

            } else { //...otherwise...

                resolve(output) //...resolves the Promise with the output
            }
        })
    })
}


/*    Function to find the root directory of the Git repository 8    */
const findGitRootDir = startDir => { // This function takes a startDir as an argument...

    let currentDir = startDir //...and initializes a variable currentDir with the value of startDir...

    while (currentDir !== path.parse(currentDir).root) { //...then enters a while loop that runs as long as currentDir is not the root directory...

        if (fs.existsSync(path.join(currentDir, '.git'))) { //...and checks if the .git directory exists in the current directory...

            return currentDir //...and if it does, returns the current directory...
        }

        currentDir = path.dirname(currentDir) //...otherwise sets the current directory to the parent directory...
    }

    throw new Error('Git root directory not found') //...and throws an error if the root directory is not found
}


/*    Function to process branches in batches    */
const processBranchesInBatches = async (branches, batchSize, processFunc) => { //This function takes branches, batchSize, and processFunc as arguments and returns a Promise...
    for (let i = 0; i < branches.length; i += batchSize) { //...which iterates over the branches array in batches of batchSize, which is set to 10 from its two calls from findRemovedFiles...

        const batch = branches.slice(i, i + batchSize) //...and slices the branches array to get the current batch...

        await processFunc(batch) //...then awaits the processFunc function with the current batch as an argument
    }
}



/* Function to check if there are uncommitted changes */
const hasUncommittedChanges = async (rootDir) => {
    try {
        const statusCommand = `git -C ${rootDir} status --porcelain`;
        const statusOutput = await execCommand(statusCommand);
        return statusOutput.length > 0; // Returns true if there are uncommitted changes
    } catch (error) {
        console.error(`Failed to check for uncommitted changes: ${error}`);
        throw error;
    }
};


/*    Function to prompt the user for an action    */ 
const promptUser = () => { // This function returns a Promise...

    return new Promise(resolve => { //...which takes a resolve argument...

        const rl = readline.createInterface({ //...and creates a readline interface...
            input: process.stdin, //...with the input set to process.stdin...
            output: process.stdout //...and the output set to process.stdout
        })

        rl.question('Would you like to:\n (1) see a list of the removed files\n (2) permanently delete all the removed files from the project\'s history\n ', answer => { //...then prompts the user with a question...

            rl.close() ///...and closes the readline interface
            resolve(answer) //...and resolves the Promise with the user's answer
        })
    })
}


/*    Function to escape spaces, brackets, and parentheses in file names    */
const escapeFileName = fileName => { // This function takes a fileName as an argument...
    return fileName.replace(/ /g, '\\ ') //...and returns the fileName with spaces, brackets, and parentheses escaped...
                   .replace(/\[/g, '\\[')
                   .replace(/\]/g, '\\]')
                   .replace(/\(/g, '\\(')
                   .replace(/\)/g, '\\)')
}


/*    Function to find all removed files in the Git repository    */
const findRemovedFiles = async () => { // This function returns a Promise...

    try {
        //...which first finds the root directory of the Git repository...
        const rootDir = findGitRootDir(__dirname) //...by calling the findGitRootDir function with the current directory as an argument...
        console.log(`Git root directory: ${rootDir}`) //...and logging the root directory to the console...

        //...then gets the list of local branches...
        const branchesCommand = `git -C ${rootDir} branch --format="%(refname:short)"` //...by setting the branchesCommand to get the list of local branches...
        const branches = await execCommand(branchesCommand) //...executing the branchesCommand to get the list of local branches...
        console.log(`Local branches: ${branches}`) //...and logging the local branches to the console...

        //...then gets the list of deleted branches from the reflog...
        const reflogBranchesCommand = `git -C ${rootDir} reflog show --all --pretty=format:%gD | grep 'refs/heads/' | sort -u` //...getting the list of branches from the reflog...

        const reflogBranches = await execCommand(reflogBranchesCommand) //...executing the reflogBranchesCommand to get the list of branches from the reflog...

        const allBranches = branches.concat(reflogBranches.map(ref => ref.replace('refs/heads/', '').trim())) //...then concatenating the branches and reflogBranches arrays to get all branches...

        console.log(`All branches (including deleted): ${allBranches}`) //...and logging all branches to the console...

        //...then finds all files ever tracked in the repository...
        let allFiles = new Set() //...by initializing a new Set called allFiles...

        await processBranchesInBatches(allBranches, 10, async batch => { //...then awaiting the processBranchesInBatches function with allBranches, 10, and an async function as arguments...
            
            for (const branch of batch) { //...which iterates over the branches in the current batch...

                const branchName = branch.trim() //...and trims the branch name...

                const allFilesCommand = `git -C ${rootDir} log ${branchName} --name-only --pretty=format: | sort -u` //...then sets the allFilesCommand to get the list of all files ever tracked in the branch...

                const branchFiles = await execCommand(allFilesCommand) //...executes the allFilesCommand to get the list of all files ever tracked in the branch...

                branchFiles.forEach(file => allFiles.add(file)) //...then adds each file to the allFiles Set...
            }

            console.log(`Processed batch of branches: ${batch}`) //...and logs the processed batch of branches to the console...
        })

        console.log(`All files ever tracked: ${Array.from(allFiles)}`) //...and logs all files ever tracked to the console...

        let currentFiles = new Set() //...initializes a new Set called currentFiles...

        //...then finds the list of files in the most recent commit of each branch...
        await processBranchesInBatches(branches, 10, async batch => { //...then awaiting the processBranchesInBatches function again with branches, 10, and an async function as arguments...

            for (const branch of batch) { //...which iterates over the branches in the current batch...

                const branchName = branch.trim() //...and trims the branch name...

                const currentFilesCommand = `git -C ${rootDir} ls-tree -r ${branchName} --name-only` //...then sets the currentFilesCommand to get the list of files in the most recent commit of the branch...

                const branchCurrentFiles = await execCommand(currentFilesCommand) //...executes the currentFilesCommand to get the list of files in the most recent commit of the branch...

                branchCurrentFiles.forEach(file => currentFiles.add(file)) //...then adds each file to the currentFiles Set...
            }

            console.log(`Processed batch of branches for current files: ${batch}`) //...and logs the processed batch of branches for current files to the console...
        })

        console.log(`Current files in the latest commits: ${Array.from(currentFiles)}`) //...and logs the current files in the latest commits to the console...

        //...then finds the files that were once tracked but are no longer present...
        const removedFiles = Array.from(allFiles).filter(file => !currentFiles.has(file)) //...by filtering the allFiles array to get the files that are not in the currentFiles Set...

        console.log(`Removed files: ${removedFiles}`) //...and logging the removed files to the console...

        if (removedFiles.length === 0) { //...then checks if there are no removed files...

            console.log('No removed files found.') //...logs that no removed files were found if none were...
            return //...and returns from the function
        }

        return { rootDir, removedFiles } //...otherwise returns an object with the rootDir and removedFiles

    } catch (error) { //...if an error occurs...

        console.error(error) //...logs the error to the console
    }
}


/*    Function to run the main logic    */
const main = async () => { // This function returns a Promise...

    try { //...which first tries to execute the main logic...

        const answer = await promptUser() //...by awaiting the promptUser function...

        const result = await findRemovedFiles() //...then awaiting the findRemovedFiles function...

        if (!result) { //...and if there is no result
            return //...returns...
        }

        const { rootDir, removedFiles } = result //...otherwise gets the rootDir and removedFiles from the result...

        if (answer === '1') { //...then checks if the user's answer is '1'...

            console.log('Files that were once tracked but are no longer present:') //...and if so logs the removed files to the console...

            removedFiles.forEach(file => console.log(file)) //...by iterating over the removed files and logging each file to the console

        } else if (answer === '2') { //...otherwise checks if the user's answer is '2'...

            const uncommittedChanges = await hasUncommittedChanges(rootDir);
            if (uncommittedChanges) {
                console.log('You have uncommitted changes. Please commit or stash them before proceeding.');
                return; // Exit if there are uncommitted changes
            };

            const escapedFiles = removedFiles.map(file => escapeFileName(file)) //...and escapes spaces, brackets, and parentheses in the file names...
            
            const deleteCommand = 'git' //...defines the deleteCommand as simply git...

            const deleteArgs = [
                'filter-branch', '-f', '--tree-filter',
                escapedFiles.map(file => `git rm -r -f --ignore-unmatch -- "${file}"`).join(' && '),
                '--', '--all'
            ] //...then sets the deleteArgs to delete the removed files from the project's history...

            console.log(`Delete command: ${deleteCommand} ${deleteArgs.join(' ')}`) //...and logs the delete command to the console...

            try { //...then tries to execute the delete command...

                await spawnCommand(deleteCommand, deleteArgs, { cwd: rootDir }) //...by executing the deleteCommand with the deleteArgs and rootDir as the current working directory...

                console.log('Removed files have been permanently deleted from the project\'s history.') //...and logs that the removed files have been permanently deleted from the project's history...

                // Cleanup steps
                console.log('Now performing cleanup...') //...logs that the cleanup is starting...

                await execCommand('git stash clear', { cwd: rootDir }) //...executes the command to clear the stash...

                console.log('Stash cleared.') //...logs that the stash has been cleared...

                await execCommand('git tag -l | xargs git tag -d', { cwd: rootDir }) //...executes the command to delete all tags...

                console.log('Tags deleted.') //...logs that the tags have been deleted...

                await execCommand('git for-each-ref --format="%(refname)" refs/original/ | xargs -n 1 git update-ref -d', { cwd: rootDir }) //...executes the command to delete original refs...

                console.log('Original refs deleted.') //...logs that the original refs have been deleted...

                await execCommand(`git reflog expire --expire=now --all`, { cwd: rootDir }) //...executes the command to expire the reflog...

                console.log('Reflog expired.') //...logs that the reflog has been expired...

                await execCommand(`git gc --prune=now --aggressive`, { cwd: rootDir }) //...executes the command to prune unreachable objects...

                console.log('Garbage collection completed (unreachable objects pruned).') //...logs that the garbage collection has been completed...

                await execCommand(`git repack -ad`, { cwd: rootDir }) //...repacks the repository to optimize storage...

                console.log('Repository repacked.') //...logs that the repository has been repacked...

                console.log('Cleanup completed 👍') //...and logs that the cleanup is completed...

            } catch (error) { //...if an error occurs...

                console.error(`Failed to delete removed files: ${error}`) //...logs that the deletion of the removed files failed...
            }

        } else { //...otherwise...

            console.log('Invalid option. Please enter 1 or 2.') //...logs that the user entered an invalid option...
        }

    } catch (error) { //...if an error occurs...

        console.error(error) //...logs the error to the console...
    }
}



main() //...the main function is called when the script runs